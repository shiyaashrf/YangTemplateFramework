<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.24 (Ruby 3.2.3) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-rajaram-netmod-yang-cfg-template-framework-01" category="info" consensus="true" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.28.0 -->
  <front>
    <title abbrev="yang-config-template-framework">Populating a list of YANG data nodes using templates</title>
    <seriesInfo name="Internet-Draft" value="draft-rajaram-netmod-yang-cfg-template-framework-01"/>
    <author fullname="Robert Peschi">
      <organization>Nokia</organization>
      <address>
        <postal>
          <city>Antwerp</city>
        </postal>
        <email>robert.peschi@nokia.com</email>
      </address>
    </author>
    <author fullname="Shiya Ashraf">
      <organization>Nokia</organization>
      <address>
        <postal>
          <city>Antwerp</city>
        </postal>
        <email>shiya.ashraf@nokia.com</email>
      </address>
    </author>
    <author fullname="Deepak Rajaram">
      <organization>Nokia</organization>
      <address>
        <postal>
          <city>Chennai</city>
        </postal>
        <email>deepak.rajaram@nokia.com</email>
      </address>
    </author>
    <date year="2025" month="March" day="03"/>
    <area>ops</area>
    <workgroup>netmod</workgroup>
    <keyword>templates</keyword>
    <keyword>profiles</keyword>
    <keyword>YANG scalability</keyword>
    <abstract>
      <?line 66?>

<t>This document presents a modeling technique for configuring large scale devices in a compact way, when the device contains many similar data node patterns. A device here refers to any such entity that acts as a netconf server. This is realized by instructing the device to locally generate repetitive patterns of data nodes from a master copy called 'template' that is configured in the device. This approach is both convenient and efficient, as it minimizes the size of the running data store and reduces network provisioning time. It leverages existing YANG specification features and can be implemented with standard, off-the-shelf tools.The concept that is described in this draft does not aim to be a standard track document and does not cover the template solution that is currently being discussed within ietf netmod.</t>
    </abstract>
    <note removeInRFC="true">
      <name>About This Document</name>
      <t>
        Status information for this document may be found at <eref target="https://datatracker.ietf.org/doc/draft-rajaram-netmod-yang-cfg-template-framework/"/>.
      </t>
      <t>
        Discussion of this document takes place on the
        netmod Working Group mailing list (<eref target="mailto:netmod@ietf.org"/>),
        which is archived at <eref target="https://mailarchive.ietf.org/arch/browse/netmod/"/>.
        Subscribe at <eref target="https://www.ietf.org/mailman/listinfo/netmod/"/>.
      </t>
    </note>
  </front>
  <middle>
    <?line 70?>

<section anchor="introduction">
      <name>Introduction</name>
      <t>This draft considers the case of a device that contains a functional entity, characterized by a well-defined data nodes pattern, that is massively replicated and where each replication instance needs individual configuration with only limited variation.</t>
      <t>Having a device manager that repetitively configures each data node for every functional instance can become complex and prone to errors. This approach may lead to issues, such as extended configuration times, increased memory usage on the device, and inefficient YANG validation processes due to the large size of the running data store. These challenges only intensify as the system scales.</t>
      <t>This draft proposes a technique to improve this, which is based on 'YANG templates' that results in a smaller running data store even when the device is very large.</t>
      <t>A 'YANG template' is the configuration of a functional entity that the device is instructed to replicate multiple times to generate copies of the entity. The technique that we address in this draft allows to generate copies with the same data node values as in the template with the possibility, though, to overrule some of these values on an individual copy basis.</t>
      <t>The general template technique detailed in this draft does not suffer from the drawbacks mentioned earlier where the device manager is explicitly configuring all device data nodes.</t>
      <t>This method is not aimed at becoming a standard itself. It is a YANG modeling technique that can be considered, where appropriate, by any implementor or standardization organization, when designing a YANG module for a specific purpose. For the sake of completeness, note that other IETF documents do mention already the use of YANG template concept for specific applications, for instance <eref target="https://datatracker.ietf.org/doc/draft-ietf-ccamp-optical-impairment-topology-yang/">draft-ietf-ccamp-optical-impairment-topology-yang</eref> and <eref target="https://datatracker.ietf.org/doc/html/rfc8795#section-5.9">RFC8795</eref>. However, they don't provide full context about the method. This draft can help clarifying and formalizing in a generic framework how to define and use YANG templates.</t>
      <t>The next sections will elaborate on some of the constructs to apply the template technique and highlight how to mitigate some potential issues. More specifically,</t>
      <ul spacing="normal">
        <li>
          <t>How to define the template of a functional entity, how to instruct the device to replicate it (including per instance variations) and</t>
        </li>
        <li>
          <t>How the replication process takes place when expanding the template into functional entity instances configuration data nodes.</t>
        </li>
      </ul>
    </section>
    <section anchor="template-technique-framework">
      <name>Template technique framework</name>
      <section anchor="provisioning-the-running-data-store">
        <name>Provisioning the running data store</name>
        <t>This section outlines how the device's running data store is utilized to implement the template technique.</t>
        <t>In the YANG model of the device, many functional instances can be organized in a list. Since a template represents the typical configuration pattern of a functional instance, it is often necessary to choose between multiple templates for replication. 
For Example: 
the device may host various types of functional instances, each with its own specific data structure. Say, one template might define data nodes for a 'function-1' type, while another template could define data nodes for a 'function-2' type.
For a given type of functional instance, different sets of values for the data nodes may be required. Say, a 'function-1' type might have templates for 'function-1-bronze-grade', 'function-1-silver-grade', and 'function-1-gold-grade' variants. As a result, multiple templates can also be organized into a list within the device's YANG model.</t>
        <t>Assume for example, that list-a and list-b data nodes need to be configured in the device. Traditionally, the tree structure will be as below:</t>
        <t>root</t>
        <artwork><![CDATA[
 +--(...)                     // out of scope
 +--rw data-nodes-pattern     // container for functional instances
    +--rw instance* [name]    // the list of functional instances 
       +--rw name             string-ascii64
       +--rw description?     string-ascii128
       +--rw data
          +--rw list-a [name] //e.g. a list of interfaces
          |  +--rw name
          |  +--rw parm-x
          |  +--rw parm-y
          +--rw list-b [name] //e.g. a list of hardware components
             +--rw name
             +--rw parm-t
             +--rw parm-u
]]></artwork>
        <t>In contrast, the YANG tree of a device using the template technique would appear as below:</t>
        <t>root</t>
        <artwork><![CDATA[
 +--(...)                     // out of scope
 +--rw data-nodes-pattern     // container for functional instances
    +--rw template* [name]    // the list of templates
    |  +--rw name             string-ascii64
    |  +--rw description?     string-ascii128
    |  +--rw data
    |     +--rw list-a [name] //e.g. a list of interfaces
    |     |  +--rw name
    |     |  +--rw parm-x 
    |     |  +--rw parm-y
    |     +--rw list-b [name] //e.g. a list of hardware components
    |        +--rw name
    |        +--rw parm-t
    |        +--rw parm-u
    +--rw instance* [name]    // the list of functional instances 
       +--rw name             string-ascii64
       +--rw description?     string-ascii128
       +--rw template?        -> /data-nodes-pattern/template/name
       +--rw data
       +--rw list-a [name] //e.g. a list of interfaces
       |  +--rw name
       |  +--rw parm-x  //overrule if present,or take it from template
       |  +--rw parm-y  //overrule if present,or take it from template
       +--rw list-b [name] //e.g. a list of hardware components
          +--rw name
          +--rw parm-t  //overrule if present,or take it from template
          +--rw parm-u  //overrule if present,or take it from template
]]></artwork>
        <t>Each entry in the template list encompasses the generic configuration data nodes that are needed for all the functional entities to be addressed by this template, as contained in the data container, in this example, data nodes of list-a and list-b. In practice, naturally, the more data nodes that can be replicated the more efficient the template technique will be.</t>
        <t>Each entry in the instance list represents a copy to be made of the data nodes pattern defined by the leaf-ref template, to create a functional entity instance. The data container contains all the data nodes needed to customize each copy of the template, by overruling one or the other data node value originating from the template (eg: parm-x, parm-y, parm-t, parm-u), or possibly to add to the copy one or the other data nodes not provided by the template.</t>
        <t>Although it is recommended that the same data nodes are defined in the data container of template and the data container of instance, only a limited number of such data nodes should be configured in the instance. This reflects the assumption that functional instances should have only limited variations from their template model.</t>
        <t>It should be noted that in a good application of the template technique, only few templates would suffice to generate a very large number of functional instances; in other words, the instance list would be much larger, typically by order of magnitudes, than the template list.</t>
        <t>A simple configuration example in the running data store of the device can be found at <xref target="a1device-running-data-store-using-the-template-mechanism">Appendix A.1</xref></t>
      </section>
      <section anchor="device-expanding-the-running-data-store">
        <name>Device expanding the running data store</name>
        <t>Once the configuration is applied to the device, the device will dynamically create each instance as specified.
The process for generating data nodes for a particular instance follows these steps:</t>
        <t>-A copy of the template's data nodes is made, serving as the foundation for the instance's configuration.</t>
        <t>-If any of these data nodes are also configured in the running data store for this instance, they will override the template values.</t>
        <t>If an instance data node is configured in the running data store but not provided by the template, it will be added to the generated instance configuration.</t>
        <t>The resulting instance expansion corresponding to the example in appendix A.1 is provided in <xref target="a2data-generated-by-the-template-mechanism">Appendix A.2</xref></t>
      </section>
      <section anchor="mandatories-and-defaults">
        <name>Mandatories and Defaults</name>
        <t>While conceptually, the idea of templates improves the re-usability and consistency factor, there are certain nuances, that need to be addressed while handling data nodes with defaults and mandatories.</t>
        <t>If certain replicable data patterns contain default or mandatory values, and are used as-is both in the template and in the instance,</t>
        <t>-There is a possibility of silent and unintentional overwriting the configured value of the node in the template with the default value in the instance due to the merge operation.</t>
        <t>-Mandatory data nodes must be unconditionally configured in the instance although they are already configured in the template, reducing the efficiency of the template mechanism.</t>
        <t>Hence, while the same data nodes are used in the templates and instances, it is imperative that instance data nodes are without default and mandatory statements.</t>
        <t>there may be different implementation to solve this, one such way that uses the existing YANG constructs is provided in <xref target="b-using-existing-yang-constructs-in-template-and-instance-yang-definition">Appendix B</xref>.</t>
      </section>
    </section>
    <section anchor="benefits-of-templates-in-yang-design">
      <name>Benefits of Templates in YANG Design</name>
      <ol spacing="normal" type="1"><li>
          <t>Reusability:
Templates encourage reusability by allowing common structures to be defined once and reused multiple times. This reduces duplication and simplifies model management.</t>
        </li>
        <li>
          <t>Consistency:
By using templates, similar configurations are defined and applied uniformly, leading to more consistent data modeling and network configuration management.</t>
        </li>
        <li>
          <t>Simplified Maintenance:
When a template is modified, all places where it is used will automatically reflect those changes, reducing the effort required to maintain and update the model.</t>
        </li>
        <li>
          <t>Modularity:
Templates promote a modular approach to YANG model design. By splitting the model into reusable parts, it becomes easier to scale and extend.</t>
        </li>
      </ol>
    </section>
    <section anchor="template-realisation-using-yang-groupings">
      <name>Template Realisation Using YANG Groupings</name>
      <t>As described in <xref target="provisioning-the-running-data-store">Provisioning the running data store</xref>, this template technique requires a similar YANG structure to be used in the list of templates(/data-nodes-pattern/template) and the list of template-consumers/instances(/data-nodes-pattern/instance). Rather than making copies of the same data nodes at different places, groupings can be used.</t>
      <artwork><![CDATA[
  grouping list-a-nodes {
    list list-a {
      leaf parm-x{
        type int
      }
      leaf parm-y{
        type string
      }
    }
  }
  grouping list-b-nodes {
    list list-b {
      leaf parm-t{
        type int
      }
      leaf parm-u{
        type string
      }
    }
  }
      
  augment "./data-nodes-pattern/template/data" {
    description "....";
    uses list-a-nodes;
    uses list-b-nodes;
  }

  augment "./data-nodes-pattern/instance/data" {
    description "....";
    uses list-a-nodes;
    uses list-b-nodes;
  }
]]></artwork>
      <section anchor="templates-for-existing-yang-models-using-yang-groupings">
        <name>Templates for existing YANG models using YANG Groupings</name>
        <t>An implementation that intends to apply the technique of templates for existing YANG models, such as ietf-interface.yang, could also realise this by copying these data nodes in to a new YANG grouping and then applying them with 'uses' statement. Below is an example implementation for data nodes defined in ietf-interfaces.yang</t>
        <artwork><![CDATA[
module xxx-interfaces-common {
  yang-version 1.1;
  namespace "urn:xxx-interfaces-common";
  prefix xxx-ifc;

  import ietf-yang-types {
    prefix yang;
  }
   // Grouping few nodes of ietf-interfaces.yang
  grouping interface-attributes {
    container interfaces {
      description
         "Interface parameters.";
      list interface {
        key "name";
        description
         "The list of interfaces on the device.
          The status of an interface is available in this list in the
          operational state.  If the configuration of a
          system-controlled interface cannot be used by the system
          (e.g., the interface hardware present does not match the
          interface type), then the configuration is not applied to
          the system-controlled interface shown in the operational
          state.  If the configuration of a user-controlled interface
          cannot be used by the system, the configured interface is
          not instantiated in the operational state.
  
          System-controlled interfaces created by the system are
          always present in this list in the operational state,
          whether or not they are configured.";
        leaf name {
          type string;
           description
             "The name of the interface.
  
              A device MAY restrict the allowed values for this leaf,
              possibly depending on the type of the interface.
              For system-controlled interfaces, this leaf is the
              device-specific name of the interface.

              If a client tries to create configuration for a
              system-controlled interface that is not present in the
              operational state, the server MAY reject the request if
              the implementation does not support pre-provisioning of
              interfaces or if the name refers to an interface that can
              never exist in the system.  A Network Configuration
              Protocol (NETCONF) server MUST reply with an rpc-error
              with the error-tag 'invalid-value' in this case.

              If the device supports pre-provisioning of interface
              configuration, the 'pre-provisioning' feature is
              advertised.
  
              If the device allows arbitrarily named user-controlled
              interfaces, the 'arbitrary-names' feature is advertised.
              When a configured user-controlled interface is created by
            the system, it is instantiated with the same name in the
            operational state.

            A server implementation MAY map this leaf to the ifName
            MIB object.  Such an implementation needs to use some
            mechanism to handle the differences in size and characters
            allowed between this leaf and ifName.  The definition of
            such a mechanism is outside the scope of this document.";
         reference
           "RFC 2863: The Interfaces Group MIB - ifName";
       }

        leaf description {
          type string;
          description
           "A textual description of the interface.

            A server implementation MAY map this leaf to the ifAlias
            MIB object.  Such an implementation needs to use some
            mechanism to handle the differences in size and characters
            allowed between this leaf and ifAlias.  The definition of
            such a mechanism is outside the scope of this document.
 
            Since ifAlias is defined to be stored in non-volatile
            storage, the MIB implementation MUST map ifAlias to the
            value of 'description' in the persistently stored
            configuration.";
         reference
           "RFC 2863: The Interfaces Group MIB - ifAlias";
           }

        leaf type {
          type identityref {
            base interface-type;
          }
          /*mandatory true;could be refined when grouping is used*/
          description
           "The type of the interface.
            When an interface entry is created, a server MAY
            initialize the type leaf with a valid value, e.g., if it
            is possible to derive the type from the name of the
            interface.

            If a client tries to set the type of an interface to a
            value that can never be used by the system, e.g., if the
            type is not supported or if the type does not match the
            name of the interface, the server MUST reject the request.
            A NETCONF server MUST reply with an rpc-error with the
            error-tag 'invalid-value' in this case.";
         reference
           "RFC 2863: The Interfaces Group MIB - ifType";
         }
  
        leaf enabled {
          type boolean;
          /*default "true";could be refined when grouping is used*/
          description
           "This leaf contains the configured, desired state of the
            interface.
  
            Systems that implement the IF-MIB use the value of this
            leaf in the intended configuration to set
            IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
            has been initialized, as described in RFC 2863.
  
            Changes in this leaf in the intended configuration are
            reflected in ifAdminStatus.";
         reference
           "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
           }  

        leaf link-up-down-trap-enable {
          type enumeration {
            enum enabled {
              value 1;
              description
                "The device will generate linkUp/linkDown SNMP
                 notifications for this interface.";
               }
            enum disabled {
              value 2;
              description
                "The device will not generate linkUp/linkDown SNMP
                notifications for this interface.";
              }
            } 
         description
         "Controls whether linkUp/linkDown SNMP notifications
          should be generated for this interface.
          If this node is not configured, the value 'enabled' is
          operationally used by the server for interfaces that do
          not operate on top of any other interface (i.e., there are
          no 'lower-layer-if' entries), and 'disabled' otherwise.";
          reference
           "RFC 2863: The Interfaces Group MIB -
                      ifLinkUpDownTrapEnable";
           }
       }//interface
     }  //interfaces
  }
}
]]></artwork>
        <t>This module could then be imported into any applicable module which needs to be modularized, thereby avoiding the need to duplicate the definitions.</t>
        <artwork><![CDATA[
module xxx-interfaces-template {
  yang-version 1.1;
  namespace "urn:xxx-interfaces-tmplt";
  prefix xxx-ifc-tmplt;

  import xxx-interfaces-common {
    prefix xxx-ifc;
  }
     container data-nodes-pattern {
       list template {
         key "name";
         leaf name {
           type string;
         }
         container data {
           uses xxx-ifc:interface-attributes;
         }
       }
     
       list instance {
         key "name";
         leaf name {
           type string;
         } 
       leaf template {
         type leafref {
           path 
              "/data-nodes-pattern/template/name";
          }
        }
        container data {
          uses xxx-ifc:interface-attributes;
        }
      } 
    }
}
]]></artwork>
      </section>
    </section>
    <section anchor="conclusion">
      <name>Conclusion</name>
      <t>Using templates in YANG allows to efficiently configure large amounts of similar data nodes while keeping the running data store size small. This is beneficial in term of device memory footprint, ease of configuration, configuration time and potentially YANG validation processing in the device. This draft explains some practicalities of the template method, including how to ensure that mandatory and default statements do not jeopardize the effectiveness of the method.</t>
      <t>In addition to the above, The template method mentioned in <xref target="template-realisation-using-yang-groupings">Template Realisation Using YANG Groupings</xref>is also beneficial for existing standard nodes as well.</t>
    </section>
    <section anchor="conventions-and-definitions">
      <name>Conventions and Definitions</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
      <?line -18?>

</section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>TODO Security</t>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
    <section anchor="appendix">
      <name>Appendix</name>
      <section anchor="a-example-of-applying-the-template-method">
        <name>A. Example of applying the template method.</name>
        <section anchor="a1device-running-data-store-using-the-template-mechanism">
          <name>A.1.Device running data store using the template mechanism</name>
          <t>In this example, one template template-1 is configured, and three instances are configured, to be derived from template-1 and with limited overruling of the template values.</t>
          <artwork><![CDATA[
 <config>
 <data-nodes-pattern>
 <template>
  <name>template-1</name>
  <description>A typical configuration</description>
  <data>
    <list-a>
      <name>templ-1-list-a-entry-1</name>
      <parm-x>1</parm-x>
      <parm-y>30</parm-y>
    </list-a>
    <list-a>
      <name>templ-1-list-a-entry-2</name>
      <parm-x>3</parm-x>
      <parm-y>30</parm-y>
    </list-a>
     <list-a>
      <name>templ-1-list-a-entry-3</name>
      <parm-x>3</parm-x>
      <parm-y>50</parm-y>
    </list-a>
    <list-b>
      <name>templ-1-list-b-entry-1</name>
      <parm-t>2</parm-t>
      <parm-u>40</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-2</name>
      <parm-t>4</parm-t>
      <parm-u>60</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-3</name>
      <parm-t>4</parm-t>
      <parm-u>80</parm-u>
    </list-b>
  </data>
</template>

<instance>                         // a first instance
  <name>instance-1</name>
  <template>template-1</template>  //config is derived from template-1
  <data>
    <list-a>
      <name>templ-1-list-a-entry-2</name> // inherited from template
      <parm-y>33</parm-y>      //overrule template value 30 with 33
    </list-a>
  </data>
</instance>

<instance>                         // a second instance
  <name>instance-2</name>
  <template>template-1</template> //config is derived from template-1
  <data>                   // nothing from template to be overruled
  </data>
</instance>

<instance>                        // a third instance
  <name>instance-3</name>
  <template>template-1</template> //config is derived from template-1
  <data>
    <list-a>
      <name>templ-1-list-a-entry-3</name> //inherited from template
      <parm-y>55</parm-y>      //overrule template value 50 with 55
    </list-a>
    <list-b>
      <name>templ-1-list-b-entry-3</name> //inherited from template
      <parm-u>88</parm-u>       //overrule template value 80 with 88
    </list-b>
  </data>
</instance>
 </data-nodes-pattern>
 </config>
]]></artwork>
        </section>
        <section anchor="a2data-generated-by-the-template-mechanism">
          <name>A2:Data generated by the template mechanism</name>
          <t>The running data store example in section A.1 leads the device to generate the following data used to control the instances (without the aid of the template mechanism, this data would need to explicitly come from the running data store, instead of being locally expanded):</t>
          <t>generated through instance-1 merged with template-1 expansion</t>
          <artwork><![CDATA[
  <data>
    <list-a>
      <name>templ-1-list-a-entry-1</name>
      <parm-x>1</parm-x>
      <parm-y>30</parm-y>
    </list-a>
    <list-a>
      <name>templ-1-list-a-entry-2</name>
      <parm-x>3</parm-x>       
      <parm-y>33</parm-y>     //deviate from template value
    </list-a>
     <list-a>
      <name>templ-1-list-a-entry-3</name>
      <parm-x>3</parm-x>
      <parm-y>50</parm-y>
    </list-a>
    <list-b>
      <name>templ-1-list-b-entry-1</name>
      <parm-t>2</parm-t>
      <parm-u>40</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-2</name>
      <parm-t>4</parm-t>
      <parm-u>60</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-3</name>
      <parm-t>4</parm-t>
      <parm-u>80</parm-u>
    </list-b>
  </data>
]]></artwork>
          <t>(generated through instance-2 merged with template-1 expansion)</t>
          <artwork><![CDATA[
  <data>
    <list-a>
      <name>templ-1-list-a-entry-1</name>
      <parm-x>1</parm-x>
      <parm-y>30</parm-y>
    </list-a>
    <list-a>
      <name>templ-1-list-a-entry-2</name>
      <parm-x>3</parm-x>       
      <parm-y>30</parm-y>
    </list-a>
     <list-a>
      <name>templ-1-list-a-entry-3</name>
      <parm-x>3</parm-x>
      <parm-y>50</parm-y>
    </list-a>
    <list-b>
      <name>templ-1-list-b-entry-1</name>
      <parm-t>2</parm-t>
      <parm-u>40</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-2</name>
      <parm-t>4</parm-t>
      <parm-u>60</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-3</name>
      <parm-t>4</parm-t>
      <parm-u>80</parm-u>
    </list-b>
  </data>
]]></artwork>
          <t>(generated through instance-3 merged with template-1 expansion)</t>
          <artwork><![CDATA[
  <data>
    <list-a>
      <name>templ-1-list-a-entry-1</name>
      <parm-x>1</parm-x>
      <parm-y>30</parm-y>
    </list-a>
    <list-a>
      <name>templ-1-list-a-entry-2</name>
      <parm-x>3</parm-x>       
      <parm-y>30</parm-y>
    </list-a>
     <list-a>
      <name>templ-1-list-a-entry-3</name>
      <parm-x>3</parm-x>
      <parm-y>55</parm-y>     //deviate from template value
    </list-a>
    <list-b>
      <name>templ-1-list-b-entry-1</name>
      <parm-t>2</parm-t>
      <parm-u>40</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-2</name>
      <parm-t>4</parm-t>
      <parm-u>60</parm-u>
    </list-b>
    <list-b>
      <name>templ-1-list-b-entry-3</name>
      <parm-t>4</parm-t>
      <parm-u>88</parm-u>     //deviate from template value
    </list-b>
  </data>
]]></artwork>
        </section>
      </section>
      <section anchor="b-using-existing-yang-constructs-in-template-and-instance-yang-definition">
        <name>B: Using existing YANG constructs in template and instance YANG definition</name>
        <t>This appendix illustrates the use of groupings in the YANG definition of template and instances and more specifically it shows how easily mandatory and default statements can be introduced in the template definition by refining the grouping uses statement.</t>
        <section anchor="the-grouping-construct">
          <name>The grouping construct</name>
          <t>By defining common structures using grouping, one avoids repeating code, ensures consistency and makes future changes easier since modifications only need to happen in one place.</t>
          <t>Example:</t>
          <artwork><![CDATA[
 grouping interface-config {
          leaf parm-a {
             type string;
          }
          leaf parm-b {
             type boolean;
          }
          leaf parm-c {
             type unint32;
          }
        }
]]></artwork>
          <t>This 'interface-config' grouping defines a common structure that can be reused across different YANG modules or different parts of the same module.</t>
        </section>
        <section anchor="the-uses-construct">
          <name>The uses construct</name>
          <t>The 'uses' statement applies a previously defined grouping where needed in the model (e.g. it copies the data nodes of the grouping at the place of the 'uses' statement.</t>
          <t>As an example, the data nodes defined in the grouping above can be used in the template and in the instance definition:</t>
          <artwork><![CDATA[
 container data-nodes-pattern {
 list template {
  key "name";
  leaf name {
    type string;
  }
  container data {
    list interface {
      key "interface-name";
      leaf name {
        type string;
      }
      uses interface-config;
    } 
   } 
  }
list instance {
  key "name";
  leaf name {
    type string;
  }
  container data {
    list interface {
      key "interface-name";
      leaf name {
        type string;
      }
      uses interface-config;
    }
   }
  }
 }
]]></artwork>
        </section>
        <section anchor="the-refine-construct-to-control-default-and-mandatory-statements">
          <name>The refine construct to control default and mandatory statements</name>
          <t>As explained in section 2.3, with the template method, some data nodes may need a default or mandatory statement when used for the template definition but should have no mandatory neither default statements when used for the instance definition.</t>
          <t>The refine statement available in existing YANG version easily allows to control mandatory and default statements when used along with the uses statement.</t>
          <t>Assume in our example that it is desired that parm-b has a default statement and parm-c has a mandatory statement when they are used for the template definition.</t>
          <t>Then the YANG becomes:</t>
          <artwork><![CDATA[
 container data-nodes-pattern {
 list template {
  key "name";
  leaf name {
    type string;
  }
  container data {
    list interface {
      key "interface-name";
      uses interface-config {
        refine parm-b {
          default "true"
        }
        refine parm-c {
          mandatory true
        }
      }
    }
  }
}
list instance {
  key "name";
  leaf name {
    type string;
  }
  container data {
    list interface {
      key "interface-name";
      uses interface-config;
    }
   }
  }
 }
]]></artwork>
        </section>
      </section>
    </section>
  </middle>
  <back>
    <references anchor="sec-normative-references">
      <name>Normative References</name>
      <reference anchor="RFC2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner"/>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba"/>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
    </references>
    <?line 784?>

<section numbered="false" anchor="acknowledgments">
      <name>Acknowledgments</name>
    </section>
  </back>
  <!-- ##markdown-source:
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
Y+4lbtL/mqx1bs3kvWv+i//8P8EE8aMdgwAA

-->

</rfc>
